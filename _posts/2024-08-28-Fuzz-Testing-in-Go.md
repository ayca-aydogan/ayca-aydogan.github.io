## Fuzz Testing in Go

In this article, I’ll cover the basics of fuzz testing and how to perform it with the built-in tools in Golang. This is actually the written in english version of the presentation I gave at Gophers Ankara in 2023 as well as GoConf Istanbul in February 2024. 

If you’re interested, you can watch the full presentation from Istanbul GoConf via [this link](https://www.youtube.com/watch?v=HQ4SX9UxicM). 

You can download the presentation from [here](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/Fuzz.pdf?raw=true).

You can find the code in demo [here](https://github.com/ayca-aydogan/FuzzTestDemo) to try it yourself.

### What is Fuzzing?

### How does it work?

### How to Fuzz?

### DEMO

The function below, called ShiftLeft(), shifts a string to the left. It rotates the string in a circular fashion by taking the first character and moving it to the end.

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_1.png?raw=true)

You can see an example of how the ShiftLeft function is used in the main function.

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_2.png?raw=true)

Typically, unit test are enough to check the code. Here are the test cases I’ve written:

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_3.png?raw=true)

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_4.png?raw=true)

The testcases seem comprehensive and the test passes. This may seem sufficient, but I also want to run a fuzz test to uncover any unexpected bugs.

Below is the fuzz test function. It's important to define the fuzzing arguments first, as the seed corpus will be based on these inputs. In this case, I specify the inputs I want the fuzz engine to generate, which are the "input" and the "shift" value. These values are then added to the seed corpus using the Add function.

At this point, it's necessary to establish some logical rules. In unit testing, the input and expected output are known. However, with fuzz testing, this isn't the case. 

First rule: It's guaranteed that valid UTF-8 strings will be passed to this function. Therefore, the first step is to filter out any non-UTF-8 values generated by the fuzz engine. After that, the ShiftLeft function is called, the output is obtained, and the first assertion is made: "If the input is valid UTF-8, the output should also be valid UTF-8."

Second rule: I verify that the input and output have the same character count, which is a logical requirement. 

Third rule: If the input is shifted to the left by its character count, the original string should be returned.
 
![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_5.png?raw=true)


Initially, I don’t activate the fuzz engine; I only verify the seed corpus. To do this, I use the -run flag: go test -run followed by the function name. This executes my four test cases, and no issues are found.

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_10.png?raw=true)


 After that, I decide to run the fuzz engine. To do this, I use go test -fuzz= followed by the function name, which starts the engine. Initially, it runs all the unit tests before activating the fuzz engine to ensure they pass. Next, there's a section called "gathering baseline coverage," where it calculates how much of the code is covered by the seed corpus. Since there are four seed corpus cases, it calculates the coverage and then begins generating inputs.

Shortly after generating inputs, an error is found: "index out of range," which triggers a panic. The engine reports that it saved this faulty condition as a file in the testdata/fuzz/shiftLeft folder, and I can confirm that the file appears there.

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_11.png?raw=true)

When I check the file, I notice that the shift amount was given as a negative value. I hadn’t included this in my unit tests. So, I make a simple fix here. I could have included the handling of negative values and made the function support them, but since this is a function that shifts left, I decide not to include negative values. Instead, if the shift is less than zero, it should directly return the input. I run it again using the -run flag to test the faulty condition, and it passes. Afterward, I run the fuzz engine again. But before that, I add this condition to my unit tests so that if I encounter this situation again, I can retest this test case.

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_12.png?raw=true)

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_13.png?raw=true)

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_14.png?raw=true)

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_15.png?raw=true)

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_16.png?raw=true)

After modifying the function, I run it again and encounter another error. This time, the error occurs on line 77, where I didn’t get the correct result when shifting the string by its own length. I see that this error is once again saved as a file in the testdata folder.

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_17.png?raw=true)

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_18.png?raw=true)


On line 77, it was converting the string to a byte array, but special characters or all UTF-8 characters don’t always consist of a single byte. To perform more accurate string manipulation in Go, I should have converted these to runes instead of bytes. I missed this. I realize it because there are actually two characters here; my input byte array should have been 2 characters long, but it ended up being 3 characters. So, I correct this, convert it to runes, and when I run this case again, it passes. I then add this case to my unit tests to avoid encountering the same error in the future.


![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_19.png?raw=true)

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_20.png?raw=true)

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_21.png?raw=true)

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_22.png?raw=true)

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_23.png?raw=true)

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_24.png?raw=true)

By the way, the inputs generated by the fuzz engine were a special character string and a shift value. However, we encountered this error in the control mechanism I implemented afterward, meaning I needed to perform a 2-character shift to detect this error. I added this control to my unit tests, thereby adding an extra test case. I run it again and see that there’s no issue. Looking at the elapsed time, it ran for a minute, and no issues occurred during that time.

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_25.png?raw=true)

Meanwhile, the fuzz engine continues running indefinitely unless stopped. Initially, our seed corpus consisted of 4 values, as you may recall, but it has now increased to 11 values.

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_26.png?raw=true)

The reason for this is that, as I mentioned earlier, when the fuzz engine finds interesting values, it saves them in the gofuzz folder. Since we ran the fuzz engine twice, it found and saved interesting values, and these were then included in the seed corpus. In the next run, we can see that in the third run, the fuzz engine found and saved new interesting values, bringing our total to 45 values.

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_27.png?raw=true)

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_28.png?raw=true)

Now, let’s do a quick calculation. I navigate to the gofuzz directory, find the path where my function is located within the fuzz folder, and see that there are 38 files in this directory. So, we have 38 interesting values, and we had found two faulty cases earlier. Under the test data folder, we initially added 4 values to the seed corpus. I also found and added one extra value. Adding that, we reach a total of 45 values.

Actually, the seed corpus grows each time with the values it previously found. And we can look at the files under this folder if we want, use them, and if we wish, we can add them to our unit tests. We just discovered that we have 45 values. Now, when it recalculates the baseline coverage, it does so considering that there are 45 values in the seed corpus and continues from there.


![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_29.png?raw=true)

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_30.png?raw=true)

I mentioned earlier that this process can continue indefinitely unless stopped. For that, we have a parameter called -fuzztime. You can specify seconds, hours, or any duration you want. And if no error is found when the time is up, the test will be considered passed, and you'll see "PASS" here.

![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_31.png?raw=true)

There’s one more thing I’d like to mention. The ten workers mentioned here refers to it running on 10 Go routines. But maybe I don't want to put that much load on my computer and prefer to have fewer workers running. In that case, you can use the -parallel flag to control how many fuzz tests run simultaneously. That concludes my demo.


![](https://github.com/ayca-aydogan/ayca-aydogan.github.io/blob/main/_posts/attachments/2024-08-28-Fuzz-Testing-in-Go/img_32.png?raw=true)

### Real life example
